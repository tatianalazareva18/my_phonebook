
# ЗАДАЧА "СКРАБЛ"

# В настольной игре Скрабл (Scrabble) каждая буква имеет определенную ценность.

#  В случае с английским алфавитом очки распределяются так:

# A, E, I, O, U, L, N, S, T, R – 1 очко;
# D, G – 2 очка;
#  B, C, M, P – 3 очка;
#  F, H, V, W, Y – 4 очка;
#  K – 5 очков;
# J, X – 8 очков;
# Q, Z – 10 очков.
# А русские буквы оцениваются так:

# А, В, Е, И, Н, О, Р, С, Т – 1 очк
# Д, К, Л, М, П, У – 2 очка;
# Б, Г, Ё, Ь, Я – 3 очка;
# Й, Ы – 4 очка;
#  Ж, З, Х, Ц, Ч – 5 очков;
#  Ш, Э, Ю – 8 очков;
# Ф, Щ, Ъ – 10 очков.
# Напишите программу, которая вычисляет стоимость введенного пользователем слова k и выводит его. Будем считать, что на вход подается только одно слово, которое содержит либо только английские, либо только русские буквы.


# def scrabble_score(k):
  # Словарь с оценками для каждой буквы
#    scores_eng = {'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'L': 1, 'N': 1, 'S': 1, 'T': 1, 'R': 1,
#                  'D': 2, 'G': 2,
#                   'B': 3, 'C': 3, 'M': 3, 'P': 3,
#                 'F': 4, 'H': 4, 'V': 4, 'W': 4, 'Y': 4,
#                   'K': 5,
#                  'J': 8, 'X': 8,
#                  'Q': 10, 'Z': 10}

#   scores_ru = {'А': 1, 'Б': 3, 'В': 1, 'Г': 3, 'Д': 2, 'Е': 1, 'Ё': 3, 'Ж': 5, 'З': 5, 'И': 1,
#                  'Й': 4, 'К': 2, 'Л': 2, 'М': 2, 'Н': 1, 'О': 1, 'П': 2, 'Р': 1, 'С': 1, 'Т': 1,
#                  'У': 2, 'Ф': 10, 'Х': 5, 'Ц': 5, 'Ч': 5, 'Ш': 8, 'Щ': 10, 'Ъ': 10, 'Ы': 4,
#                'Ь': 3, 'Э': 8, 'Ю': 8, 'Я': 3}

#    # Инициализация переменной для подсчета общего количества очков
#    total_score = 0

    # Проходимся по каждой букве в слове и добавляем очки к общему счету
#      for letter in k.upper():
#          if letter in scores_eng:
#              total_score += scores_eng[letter]
#         elif letter in scores_ru:
#            total_score += scores_ru[letter]

#     return total_score

#Запрос слова у пользователя
# k = input("Введите слово: ")

# Вычисление и вывод стоимости слова
# score = scrabble_score(k)
# print(score)

#зАДАЧА. ПЕРЕСЕЧЕНИЕ ДВУХ НЕУПОРЯДОЧНЫХ НАБОРОВ ЦЕЛЫХ ЧИСЕЛ


# Даны два неупорядоченных набора целых чисел (может быть, с повторениями). 
# Выдать без повторений в порядке возрастания все те числа, которые встречаются в обоих наборах.
# На вход подается 2 числа через пробел: n m
# n - кол-во элементов первого множества.
# m - кол-во элементов второго множества.
# Затем подаются элементы каждого множества через пробел в виде строки. ! Писать input() не надо


# РЕШЕНИЕ

# def intersection_of_sets(n, m, set1, set2):
#     Преобразуем строки в множества целых чисел
#     set1 = set(map(int, set1.split()))
#     set2 = set(map(int, set2.split()))

#     Находим пересечение множеств
#     intersection = set1.intersection(set2)

#     # Выводим результат в отсортированном порядке
#     result = sorted(intersection)

#     return result

# # Считываем входные данные
# n, m = map(int, input().split())
# set1 = input()
# set2 = input()

# # Получаем результат и выводим его
# result = intersection_of_sets(n, m, set1, set2)
# print(*result)

# var1 = '5 4'
# var2 = '1 13 5 7 9'
# var3 = '2 13 4 5'

# res = []

# arr2 = var2.split(' ')
# arr3 = var3.split(' ')
# for i in arr2:
#     if i in arr3:
#         res.append(int(i))

# res = map(str, sorted(res))

# print(' '.join(res))  

# РЕШЕНИЕ 2

# mol = [int(x) for x in var1.split()]
# n = mol[0]
# m = mol[1]
# set_1 = set()
# set_2 = set()
# list_1 = list()
# a = [int(x) for x in var2.split()]
# k = set(a)
# for i in k:
#    set_1.add(i)
# b = [int(x) for x in var3.split()]
# k1 = set(b)
# for i in k1:
#    set_2.add(i)
# lok = set_1 & set_2
# kool = list(lok)
# kool.sort()
# for i in kool:
#    print(i, end=' ')

# В фермерском хозяйстве в Карелии выращивают чернику. Черника растет на круглой грядке, 
# и кусты черники высажены по окружности грядки. Каждый куст черники имеет урожайность, 
# которая соответствует количеству ягод на этом кусте.

# Урожайность черничных кустов представлена в виде списка arr, где 
# arr[i] - это урожайность (количество ягод) i-го куста.

# В фермерском хозяйстве внедрена система автоматического сбора черники. 
# Эта система состоит из управляющего модуля и нескольких собирающих модулей.
# Каждый собирающий модуль может собрать ягоды с одного куста и с двух соседних кустов. 
# Собирающий модуль находится перед определенным кустом, и он может выбирать, с какого куста начать сбор ягод.

# Ваша задача - написать программу, которая определит максимальное число ягод, 
# которое может собрать один собирающий модуль за один заход, находясь перед некоторым кустом грядки.

# Входные данные:На вход программе подается список arr, где arr[i] (1 ≤ arr[i] ≤ 1000) - урожайность i-го куста 
# Размер списка не превышает 1000 элементов.

# Выходные данные:Программа должна вывести одно целое число - максимальное количество ягод, 
# оторое может собрать собирающий модуль, находясь перед некоторым кустом грядки.

# На входе:arr = [5, 8, 6, 4, 9, 2, 7, 3]
# На выходе : 19



# def max_berry_collection(arr):
#     n = len(arr)
#     max_collected = 0

#     # Перебираем все кусты
#     for i in range(n):
#         # Вариант 1: собрать только с текущего куста
#         option1 = arr[i]
#         # Вариант 2: собрать с текущего и следующего кустов
#         option2 = arr[i] + arr[(i + 1) % n]
#         # Вариант 3: собрать с текущего и предыдущего кустов
#         option3 = arr[i] + arr[(i - 1) % n]

#         # Находим максимальное количество ягод
#         max_option = max(option1, option2, option3)

#         # Обновляем максимальное количество собранных ягод
#         max_collected = max(max_collected, max_option)

    #return max_collected

# Пример использования
#arr = [5, 8, 6, 4, 9, 2, 7, 3]
#result = max_berry_collection(arr)
#print(result)

# arr = [5, 8, 6, 4, 9, 2, 7, 3]
# arr_count = list()
# for i in range(len(arr) - 1):
#     arr_count.append(arr[i - 1] + arr[i] + arr[i + 1])
# arr_count.append(arr[-2] + arr[-1] + arr[0])

# # Вывод максимальной урожайности, которую может собрать собирающий модуль
# print(max(arr_count))

# n = len(arr)

# collected = 0

# collected_max = 0

# for i in range(n):
#     if i < n - 1:
#         i_next = i + 1
#     else:
#         i_next = 0
    
#     if i > 0:
#         i_prev = i - 1
#     else:
#         i_prev = n - 1

#     collected = arr[i] + arr[i_next] + arr[i_prev]
#     if collected > collected_max:
#         collected_max = collected

# print(collected_max)



    


#Напишите функцию f, которая на вход принимает два числа a и b, и возводит число a в целую степень b 
#с помощью рекурсии.

#Функция не должна ничего выводить, только возвращать значение.



# def f(a, b):
#     # Базовый случай: если степень равна 0, результат всегда 1
#     if b == 0:
#         return 1
#     # Базовый случай: если степень равна 1, результат равен основанию
#     if b == 1:
#         return a
#     # Рекурсивный случай: вычисляем a^(b//2) и используем его для уменьшения количества операций 
#     возведения в степень
#     half_power = f(a, b // 2)
#     # Если степень четная
#     if b % 2 == 0:
#         return half_power * half_power
#     # Если степень нечетная
#     else:
#         return half_power * half_power * a



# # Пример использования
# a = int(input("Введите основание a: "))
# b = int(input("Введите степень b: "))

# result = f(a, b)
# print("Результат возведения", a, "в степень", b, ":", result)

# def f(a, b):
#     if b == 1:
#         return a
#     if b == 0:
#         return 1
#     if b % 2 == 0:
#         return f(a * a, b // 2)
#     else:
#         return f(a * a, b // 2) * a


# Решение 2
# def f(a, b):
#   if b == 0:
#     return 1
#   return f(a, b - 1) * a

#Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых неотрицательных чисел. 
#Из всех арифметических операций допускаются только +1 и -1. Также нельзя использовать циклы.

#Функция не должна ничего выводить, только возвращать значение.

#Определить индексы элементов массива (списка), значения которых принадлежат заданному диапазону 
#(т.е. не меньше заданного минимума и не больше заданного максимума).
#На вход подается список с элементами list_1 
#и границы диапазона в виде чисел min_number, max_number.



# list_1 = [-5, 9, 0, 3, -1, -2, 1, 4, -2, 10, 2, 0, -9, 8, 10, -9, 0, -5, -5, 7] # на вход подается список

# min_number = 0 #границы диапазона отмечены минимальным и максималльным значением
# max_number = 10
   # РЕШЕНИЕ №1


# def define_index(list_, min_i, max_i): ИСПОЛЬЗУЕМ ФУНКЦИЮ. ФУНКЦИЯ ПРИНИМАЕТ СПИСОК И МИН И МАКС ЗНАЧЕНИЯ
#     result = [] СОЗДАЕТСЯ ПУСТОЙ СПИСОК
#     for i in range(len(list_)): ПРОХОДИМ ЦИКЛОМ ПО ИНДЕКСАМ НАШЕГО СПИСКА  list_
#         if max_i >= list_[i] >= min_i: СРАВНИВАЕМ, ЧТОБЫ ТЕКУЩИЙ ИНДЕКС БЫЛ =ИЛИ<МАКС И=ИЛИ>МИН
#             result.append(i) ЕСЛИ УСЛОВИЕ ВЫПОЛНЯЕТСЯ, ТО ИНДЕКС ДОБАВЛЯЕМ В СПИСОК

#     return result  РЕЗУЛЬТАТ ВОЗВРАЩАЕМ

# print(*define_index(list_1, min_number, max_number), sep="\n") ВЫВОДИМ ИНДЕКСЫ

#   РЕШЕНИЕ №2

# for i in range(len(list_1)):
#   if min_number <= list_1[i] <= max_number:
#     print(i)

# ЗАДАЧА. Арифметическая прогрессия

#Заполните массив элементами арифметической прогрессии. 
#Её первый элемент a1 , разность d и количество элементов n будет задано автоматически. 
#Формула для получения n-го члена прогрессии: an = a1 + (n-1) * d.

# a1 = 2
# d = 3
# n = 4

# print(*range(a1, a1+n*d, d), sep="\n")

#ЗАДАЧА. print_operation_table

#Напишите функцию print_operation_table(operation, num_rows, num_columns), 
#которая принимает в качестве аргумента функцию, вычисляющую элемент по номеру строки и столбца.
# По умолчанию номер столбца и строки = 9.
#Аргументы num_rows и num_columns указывают число строк и столбцов таблицы, которые должны быть распечатаны.
#Нумерация строк и столбцов идет с единицы (подумайте, почему не с нуля).
#Если строк меньше двух, выдайте текст
#ОШИБКА! Размерности таблицы должны быть больше 2!.
#Примечание: бинарной операцией называется любая операция, у которой ровно два аргумента, 
#как, например, у операции умножения.
#Между элементами должен быть 1 пробел, в конце строки пробел не нужен.



# def print_operation_table(operation, num_rows = 9, num_columns = 9):
#     if num_columns > 2 and num_rows > 2:
#         for i in range(1, num_rows + 1):
#             my_list = []
#             for j in range(1, num_columns + 1):
#                 my_list.append(operation(i, j))

#             print(*my_list)

#     else:
#          print('ОШИБКА! Размерности таблицы должны быть больше 2!')     

# print_operation_table(lambda x, y: x * y, 3, 3)

#ЗАДАЧА Винни Пух

#Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм. Поскольку разобраться в его кричалках 
#не настолько просто, насколько легко он их придумывает, Вам стоит написать программу.
#Винни-Пух считает, что ритм есть, если число слогов (т.е. число гласных букв) в каждой фразе стихотворения 
#одинаковое.Фраза может состоять из одного слова, если во фразе несколько слов, то они разделяются дефисами.
#Фразы отделяются друг от друга пробелами.Стихотворение  Винни-Пух передаст вам автоматически в переменную stroka
# в виде строки. В ответе напишите Парам пам-пам, если с ритмом все в порядке и Пам парам, если с ритмом все 
#не в порядке.Если фраза только одна, то ритм определить не получится и необходимо 
#вывести: Количество фраз должно быть больше одной!.

#РЕШЕНИЕ
#Для решения этой задачи мы можем разбить строку stroka на отдельные фразы, 
#подсчитать количество гласных в каждой фразе и проверить, одинаково ли они количество. 


#stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'



# def count_vowels(word):
#     vowels = 'aeiouаеёиоуыэюя'#задаем переменную строку
#     return sum(1 for char in word if char.lower() in vowels)# пишем функцию , где суммируем все знаки, 
#                                                       #если они в нижнем регистре и являются гласными буквами
# def check_rhythm(stroka):#разбиваем строку на отдельные фразы
#     phrases = stroka.split()

#     # Проверяем, что количество фраз больше одной
#     if len(phrases) <= 1:
#         return "Количество фраз должно быть больше одной!"

#     # Подсчитываем количество гласных в каждой фразе
#     vowel_counts = [count_vowels(phrase.replace('-', '')) for phrase in phrases]

#     # Проверяем, все ли фразы имеют одинаковое количество гласных
#     if len(set(vowel_counts)) == 1:
#         return "Парам пам-пам"
#     else:
#         return "Пам парам"

# # Пример использования
# stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'
# result = check_rhythm(stroka)
# print(result)



# f = open('data.txt', 'r', encoding='utf-8')
# #print(f.readline())
# print(f.readlines())
# f.close()#обязательно нужно закрыть файл



# def clear_and_write():
#     with open('data.txt', 'w', encoding='utf -8') as file:
#         file.write('Anna\n')


# def append_row():
#     with open('data.txt', 'a', encoding='utf -8') as file:
#         file.write('ivan\n')

# Задача №49. 
# Создать телефонный справочник с возможностью импорта и экспорта данных в формате .txt. 
# Фамилия, имя, отчество, номер телефона - данные, которые должны находиться в файле.
# 1. Программа должна выводить данные
# 2. Программа должна сохранять данные втекстовом файле
# 3. Пользователь может ввести одну из характеристик для поиска определенной записи(имя или фамилию человека)
# 4. Использование функций. Ваша программа не должна быть линейной
'''
1. Создание файла:+++
    - открываем файл на дозапись # a+++
2. Добавление контакта: +++
        -запросить у пользователя данные контакта +++
        -открываем файл на дозапись # a  +++
        -добавить новый контакта  +++
3. Вывод данных на экран: +++
        -открыть файл на чтение # r +++
        -считать файла  +++    
        -вывести данные на экран  +++
4. Поиск контакта:
        - выбор варианта поиска
        -запросить данные для поиска
        -открываем файл на чтение
        -считываем данные контакта, сохранили в переменную
        - осуществляем поиск контакта
        - выводим на экран найденный контакта
5. Создание юзеринтерфейса(UI): +++
        -вывести меню на экран     +++ 
        -запросить у пользователя вариант действия +++
        - запустить соответстующую функцию +++
        -осуществить возможность выхода из программы +++
'''
# Ниже прописываем функции, где запрашиваем данные контакта, по которому будем вести поиск. с помощью title
#приводим любой ввод к заглавной букве
def input_surname():
    return input('Введите фамилию контакта: ').title()

def input_name():
    return input('Введите имя контакта: ').title()

def input_patronymic():
    return input('Введите отчество контакта: ').title()

def input_phone():
    return input('Введите телефон контакта: ')

def input_address():
    return input('Введите адрес(город) контакта: ').title()

def read_phonebook():
    with open('phonebook.txt', 'r', encoding='utf-8') as file:
        contacts_str = file.read()
    return contacts_str.rstrip().split('\n\n')

def write_phonebook(contact_list):
    # print(str.join('\n\n', contact_list))
    with open('phonebook.txt', 'w', encoding='utf-8') as file:
        file.write(str.join('\n\n', contact_list))

def make_contact(surname, name, patronymic, phone, address):
    return f'{surname} {name} {patronymic}: {phone}\n{address}' 

def edit_contact():
    idx = int(input('выберите индекс контакта: '))
    contact_list = read_phonebook()
    while ( idx > len(contact_list) - 1 ):
        print('некорректный ввод! Индекс должен быть меньше ' + len(contact_list))
        idx = input('выберите индекс контакта: ')

    contact = contact_list[idx]
    print('Изменить данные контакта: ')
    print(contact)

    surname = input_surname()
    name = input_name()
    patronymic = input_patronymic()
    phone = input_phone()
    address = input_address()

    contact_list[idx] = make_contact(surname, name, patronymic, phone, address)
    write_phonebook(contact_list)

def delete_contact():
    idx = int(input('выберите индекс контакта: '))
    contact_list = read_phonebook()
    while ( idx > len(contact_list) - 1 ):
        print('некорректный ввод! Индекс должен быть меньше ' + len(contact_list))
        idx = input('выберите индекс контакта: ')

    contact = contact_list[idx]
    print('Вы хотите удалить этот контакт? ')
    print(contact)
    var = input('если "Да" введите 1: ')
    if var == '1':
        contact_list.pop(idx)
        write_phonebook(contact_list)
    

def creat_contact():# создаем соответ.переменные и вызываем эти функции и получаем данные для создания контакта
    surname = input_surname()
    name = input_name()
    patronymic = input_patronymic()
    phone = input_phone()
    address = input_address()
    return f'{surname} {name} {patronymic}: {phone}\n{address}\n\n' 


def add_contact():#создаем контакт в виде строки, сохраняем в переменную, открываем файл на дозапись 
    contact_str = creat_contact()
    with open('phonebook.txt', 'a', encoding='utf-8') as file:
        file.write(contact_str)#дозаписываем контакт в файл
     
def print_contacts():#выводим контакты
    with open('phonebook.txt', 'r', encoding='utf-8') as file:#открываем файл на считывание
        contacts_str = file.read()#помещаем в переменную весь файл в виде одной строки
    #print([contacts_str])
    contacts_list = contacts_str.rstrip().split('\n\n')#строку контактов переделываем в список контактов.С помощью 
    for n, contact in enumerate(contacts_list, 1):      #rstrip убираем пробелы справа и нумеруем
        print(n, contact)
   
def search_contact():#поиск контакта.Выводим на экран возможные варианты поиска
    print(
            'Возможные варианты поиска:\n'
            '1. По фамилии\n'
            '2. По имени\n'
            '3. По отчетству\n'
            '4. По номеру телефона\n'
            '5. По адресу\n'
        )
    var = input('выберите вариант поиска: ')#пользователь выбирает выриант
    while var not in ('1', '2', '3', '4', '5'):#попадает в цикл, если вводит неверный вариант
            print('некорректный ввод!')
            var = input('выберите вариант поиска: ')
    i_var = int(var) - 1#преобазуем значение var в интовое значение и помещаем в переменную i_var (индекс)

    search = input('Введите данные для поиска: ').title()
    with open('phonebook.txt', 'r', encoding='utf-8') as file:
        contacts_str = file.read()
    #print([contacts_str])
    contacts_list = contacts_str.rstrip().split('\n\n')
    #print(contacts_list)

    for str_contact in contacts_list:
        lst_contact = str_contact.replace(':', '').split()
        if search in lst_contact[i_var]:
            print(str_contact)

                
def interface():
    with open('phonebook.txt', 'a', encoding='utf-8'):#открываем файл на дозапись Просто создает запись
        pass

    var = 0    
    while var != '6':#вариант выхода
        print(
            'Возможные варианты действия:\n'
            '1. Добавить контакт\n'
            '2. Вывести на экран\n'
            '3. Поиск контакта\n'
            '4. Редактирование контакта\n'
            '5. Удаление контакта\n'
            '6. Выход'
        )
        print()#пустая строка для красоты

        var = input('выберите вариант действия: ')
        while var not in ('1', '2', '3', '4', '5', '6'):
            print('некорректный ввод!')
            var = input('выберите вариант действия: ')
        print()
        
        match var:
            case '1':
                add_contact()
            case '2':
                print_contacts()
            case '3':
                search_contact()
            case '4':
                edit_contact()
            case '5':
                delete_contact()
            case '6':
                print('До свидания!')
        print()
    
if __name__== '__main__': 
    interface()


       